# Specify the minimum required version of CMake.
# Version 3.12 is a reasonable baseline for modern CMake features.
cmake_minimum_required(VERSION 3.12)

# Define the project name.
project(HyPhy VERSION 2.5)

# Enable testing with CTest.
enable_testing()

# Set the default build type to Release.
# This can be overridden by the user with -D CMAKE_BUILD_TYPE=<type>
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the type of build, options are: Release, Debug, RelWithDebInfo, MinSizeRel.")
endif()

#===============================================================================
# Project Options
#===============================================================================

# Provide options to disable specific instruction sets or libraries.
# These can be toggled by the user during configuration (e.g., -DNOAVX=ON).
option(NOAVX "Disable AVX instructions" OFF)
option(NOSSE4 "Disable SSE4 instructions" OFF)
option(NONEON "Disable NEON instructions" OFF)
option(NOZLIB "Disable ZLIB support" OFF)
option(NOBLAS "Disable BLAS support" OFF)

#===============================================================================
# CPU Feature Detection
#
# These functions check for the availability of specific CPU instruction sets.
# Using functions encapsulates the detection logic and improves readability.
#===============================================================================

include(CheckCXXSourceRuns)

# Function to check for SSE4.1 support.
function(check_sse4_support)
  set(CMAKE_REQUIRED_FLAGS "-msse4.1")
  check_cxx_source_runs("
    #include <smmintrin.h>
    #include <stdio.h>
    int main () {
      __m128d a, b;
      double vals[2] = {0};
      a = _mm_loadu_pd(vals);
      b = _mm_hadd_pd(a,a);
      _mm_storeu_pd(vals, _mm_blend_pd(a,b,2));
      printf(\"%g\", vals[0]);
      return 0;
    }" HAVE_SSE4_EXTENSIONS)
endfunction()

# Function to check for NEON support.
function(check_neon_support)
  check_cxx_source_runs("
    #include <stdio.h>
    #include <arm_neon.h>
    int main() {
      double array[4] = {4.,2.,3.,4};
      float64x2_t a1 = vld1q_f64(array);
      float64x2_t a2 = vld1q_f64(array+2);
      a1 = vmulq_f64(a1,a2);
      vst1q_lane_f64(array, a1, 0);
      printf(\"%g\", array[0]);
      return 0;
    }" HAVE_NEON_EXTENSIONS)
endfunction()

# Function to check for AVX2 support.
function(check_avx_support)
  set(CMAKE_REQUIRED_FLAGS "-mavx2")
  check_cxx_source_runs("
    #include <immintrin.h>
    #include <stdio.h>
    int main () {
      __m256d a, b;
      double vals[4] = {0.};
      a = _mm256_loadu2_m128d(vals, vals+2);
      b = _mm256_permute4x64_pd(_mm256_hadd_pd(a,a), 2);
      _mm256_storeu_pd(vals, b);
      printf(\"%g\", vals[0]);
      return 0;
    }" HAVE_AVX_EXTENSIONS)
endfunction()

# Function to check for FMA3 support.
function(check_fma3_support)
  set(CMAKE_REQUIRED_FLAGS "-mavx2 -mfma")
  check_cxx_source_runs("
    #include <immintrin.h>
    #include <stdio.h>
    int main () {
      __m256d a, b, c;
      double vals[4] = {2.};
      a = _mm256_loadu_pd(vals);
      b = _mm256_loadu_pd(vals);
      c = _mm256_loadu_pd(vals);
      a = _mm256_fmadd_pd(a, b, c);
      _mm256_storeu_pd(vals, a);
      printf(\"%g\", vals[0]);
      return 0;
    }" HAVE_FMA3)
endfunction()

#===============================================================================
# Source File Management
#
# Using file(GLOB CONFIGURE_DEPENDS) allows for pattern-based source file
# discovery while ensuring that newly added/removed files trigger a reconfiguration.
#===============================================================================
file(GLOB SRC_CORE CONFIGURE_DEPENDS "src/core/*.cpp")
file(GLOB SRC_NEW CONFIGURE_DEPENDS "src/new/*.cpp")
file(GLOB SRC_CONTRIB CONFIGURE_DEPENDS "src/contrib/*.cpp")

set(SRC_UNIXMAIN src/mains/unix.cpp)
set(SRC_UTILS src/utils/hyphyunixutils.cpp)

set(SRC_COMMON ${SRC_CORE} ${SRC_NEW} ${SRC_UTILS} ${SRC_CONTRIB})

#===============================================================================
# Common Code as an OBJECT Library
#
# An OBJECT library compiles source files but doesn't link them into a
# static or shared library. This is efficient for sharing common code
# among multiple executable targets without recompiling.
#===============================================================================
add_library(hyphy_objects OBJECT ${SRC_COMMON})

# Add include directories required by the common code.
# PUBLIC visibility ensures that targets linking against hyphy_objects
# also get these include directories.
target_include_directories(hyphy_objects PUBLIC
  src/core/include
  src/contrib
  src/new/include
)

#===============================================================================
# Compiler and Linker Flags
#===============================================================================

# Set the C++ standard required for the project.
# This is the modern way to specify the standard, letting CMake handle
# the appropriate compiler flags.
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF) # Use -std=c++14 instead of -std=gnu++14

# Set common compiler flags for all targets.
# Using target_compile_options is preferred over global CMAKE_CXX_FLAGS.
target_compile_options(hyphy_objects INTERFACE
  -fsigned-char
  -Wall
  -Wextra
  -Weffc++
  -D__UNIX__
)

# Handle GCC specific settings.
if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)
  execute_process(COMMAND ${CMAKE_CXX_COMPILER} -dumpversion OUTPUT_VARIABLE GCC_VERSION)
  if(${GCC_VERSION} VERSION_LESS 4.9)
    message(FATAL_ERROR "GCC 4.9 or later is required.")
  endif()
  target_compile_options(hyphy_objects INTERFACE -O3 -D_FORTIFY_SOURCE=2)
endif()

# Handle Clang specific settings.
if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    target_compile_options(hyphy_objects INTERFACE -O3 -D_FORTIFY_SOURCE=2)
endif()

# CPU-specific compiler flags
if(NOT NOAVX)
  check_avx_support()
  if(HAVE_AVX_EXTENSIONS)
    target_compile_options(hyphy_objects INTERFACE -march=native -mtune=native -mavx2)
    target_compile_definitions(hyphy_objects INTERFACE _SLKP_USE_AVX_INTRINSICS)
    check_fma3_support()
    if(HAVE_FMA3)
      target_compile_options(hyphy_objects INTERFACE -mfma)
      target_compile_definitions(hyphy_objects INTERFACE _SLKP_USE_FMA3_INTRINSICS)
    endif()
  else()
    check_sse4_support()
    if(HAVE_SSE4_EXTENSIONS)
      target_compile_definitions(hyphy_objects INTERFACE _SLKP_USE_SSE_INTRINSICS)
      target_compile_options(hyphy_objects INTERFACE -msse4.1)
    endif()
  endif()
else()
  if(NOT NOSSE4)
    check_sse4_support()
    if(HAVE_SSE4_EXTENSIONS)
      target_compile_definitions(hyphy_objects INTERFACE _SLKP_USE_SSE_INTRINSICS)
      target_compile_options(hyphy_objects INTERFACE -msse4.1)
    endif()
  else()
    if(NOT CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
        target_compile_options(hyphy_objects INTERFACE -mno-sse3)
    endif()
  endif()
endif()

if(NOT NONEON)
  check_neon_support()
  if(HAVE_NEON_EXTENSIONS)
    target_compile_definitions(hyphy_objects INTERFACE _SLKP_USE_ARM_NEON)
    target_compile_options(hyphy_objects INTERFACE -mcpu=native -mtune=native)
  endif()
endif()

#===============================================================================
# Find Dependencies
#===============================================================================

# Find OpenMP
find_package(OpenMP)

# Find CURL
find_package(CURL)
if(CURL_FOUND)
  target_compile_definitions(hyphy_objects INTERFACE __HYPHYCURL__)
endif()

# Find ZLIB
if(NOT NOZLIB)
  find_package(ZLIB)
  if(ZLIB_FOUND)
    target_compile_definitions(hyphy_objects INTERFACE __ZLIB__)
    # For system-provided libraries like ZLIB, it's often necessary to
    # explicitly add include directories.
    target_include_directories(hyphy_objects INTERFACE ${ZLIB_INCLUDE_DIRS})
  endif()
endif()

# Find BLAS
if(NOT NOBLAS)
  find_package(BLAS)
  if(BLAS_FOUND)
    target_compile_definitions(hyphy_objects INTERFACE _SLKP_USE_APPLE_BLAS)
  endif()
endif()

# Default libraries
if(NOT CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
	set(DEFAULT_LIBRARIES dl)
endif()

#===============================================================================
# Executable Targets
#===============================================================================

# Define a function to create a HyPhy executable. This reduces code duplication.
function(add_hyphy_executable target_name)
  add_executable(${target_name} ${SRC_UNIXMAIN})
  target_sources(${target_name} PRIVATE $<TARGET_OBJECTS:hyphy_objects>)
  target_link_libraries(${target_name} PRIVATE ${DEFAULT_LIBRARIES})

  # Link dependencies found earlier
  if(OpenMP_FOUND)
    target_link_libraries(${target_name} PRIVATE OpenMP::OpenMP_CXX)
  endif()

  if(CURL_FOUND)
    target_link_libraries(${target_name} PRIVATE ${CURL_LIBRARIES})
  endif()

  if(ZLIB_FOUND)
    target_link_libraries(${target_name} PRIVATE ZLIB::ZLIB)
  endif()

  if(BLAS_FOUND AND NOT NOBLAS)
    target_link_libraries(${target_name} PRIVATE ${BLAS_LIBRARIES})
  endif()

  # Set the install destination
  install(TARGETS ${target_name} RUNTIME DESTINATION bin OPTIONAL)
endfunction()

# --- Main HyPhy Executable ---
add_hyphy_executable(hyphy)
target_compile_definitions(hyphy PRIVATE __MP__ __MP2__)
add_custom_target(MP DEPENDS hyphy)

# --- MPI Executable ---
find_package(MPI)
if(MPI_FOUND)
  add_hyphy_executable(HYPHYMPI)
  target_compile_definitions(HYPHYMPI PRIVATE __HYPHYMPI__)
  target_include_directories(HYPHYMPI PRIVATE ${MPI_CXX_INCLUDE_PATH})
  target_compile_options(HYPHYMPI PRIVATE ${MPI_CXX_COMPILE_FLAGS})
  target_link_libraries(HYPHYMPI PRIVATE ${MPI_CXX_LIBRARIES})
  set_target_properties(HYPHYMPI PROPERTIES COMPILE_FLAGS "${OpenMP_CXX_FLAGS}" LINK_FLAGS "${MPI_LINK_FLAGS} ${OpenMP_CXX_FLAGS}")
  install(TARGETS HYPHYMPI RUNTIME DESTINATION bin OPTIONAL)
  add_custom_target(MPI DEPENDS HYPHYMPI)
endif()

# --- Profile Executable ---
add_hyphy_executable(HYPHYPROFILE)
target_compile_options(HYPHYPROFILE PRIVATE -g -fprofile-generate -fanalyzer)
target_link_options(HYPHYPROFILE PRIVATE -g -fprofile-generate -fanalyzer)
add_custom_target(PROFILE DEPENDS HYPHYPROFILE)

# --- GPerf Executable ---
add_hyphy_executable(HYPHYGPERF)
if(OPENMP_FOUND)
    target_link_libraries(HYPHYGPERF PRIVATE ${DEFAULT_LIBRARIES} OpenMP::OpenMP_CXX)
endif()
target_compile_options(HYPHYGPERF PRIVATE -g)
target_link_options(HYPHYGPERF PRIVATE -g -lprofiler -ltcmalloc)
add_custom_target(GPERF DEPENDS HYPHYGPERF)


# --- Debug Executable ---
add_hyphy_executable(HYPHYDEBUG)
target_compile_definitions(HYPHYDEBUG PRIVATE __HYPHYDEBUG__)
target_compile_options(HYPHYDEBUG PRIVATE -g -fsanitize=address -O0)
target_link_options(HYPHYDEBUG PRIVATE -g -fsanitize=address -O0)
add_custom_target(DEBUG DEPENDS HYPHYDEBUG)


# --- Target-specific Properties ---
set_property(TARGET hyphy HYPHYDEBUG HYPHYPROFILE APPEND PROPERTY COMPILE_DEFINITIONS _HYPHY_LIBDIRECTORY_="${CMAKE_INSTALL_PREFIX}/share/hyphy")

#===============================================================================
# Installation
#===============================================================================
# Set a default installation prefix if not provided by the user.
if(NOT CMAKE_INSTALL_PREFIX)
    set(CMAKE_INSTALL_PREFIX "/usr/local" CACHE PATH "Installation prefix")
endif()

# Install the resource files.
install(DIRECTORY res/ DESTINATION share/hyphy)

# Add an uninstall target.
add_custom_target(uninstall
    COMMAND ${CMAKE_COMMAND} -P "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
)
configure_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/cmake/cmake_uninstall.cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
    IMMEDIATE @ONLY
)

#===============================================================================
# Documentation Generation
#===============================================================================
find_program(NODE_EXECUTABLE npm)
if(NOT NODE_EXECUTABLE)
    message(STATUS "npm not found. API documentation will not be generated.")
else()
    add_custom_target(docs
        COMMAND npm install -g documentation@4
        COMMAND documentation build --polyglot -f md ./res/TemplateBatchFiles/libv3/**/*.bf -o ./docs.md
        VERBATIM
    )
endif()

#===============================================================================
# Testing
#===============================================================================
set(HYPHY_ENV_ARG "ENV=TOLERATE_NUMERICAL_ERRORS=1;")

add_test (NAME UNIT-TESTS COMMAND bash run_unit_tests.sh)
add_test (CODON HYPHYMP tests/hbltests/SimpleOptimizations/SmallCodon.bf)
add_test (PROTEIN HYPHYMP tests/hbltests/SimpleOptimizations/IntermediateProtein.bf)
add_test (MTCODON HYPHYMP tests/hbltests/libv3/mtDNA-code.wbf)
add_test (ALGAE HYPHYMP tests/hbltests/libv3/algae-mtDNA.wbf)
add_test (CILIATES HYPHYMP tests/hbltests/libv3/ciliate-code.wbf)
add_test (NAME SLAC COMMAND HYPHYMP tests/hbltests/libv3/SLAC.wbf)
add_test (NAME SLAC-PARTITIONED COMMAND HYPHYMP tests/hbltests/libv3/SLAC-partitioned.wbf)
add_test (NAME FEL COMMAND HYPHYMP tests/hbltests/libv3/FEL.wbf)
add_test (MEME HYPHYMP tests/hbltests/libv3/MEME.wbf)
#add_test (MEME_MPI mpirun -np 4 HYPHYMPI tests/hbltests/libv3/MEME.wbf)
add_test (MEME-PARTITIONED HYPHYMP tests/hbltests/libv3/MEME-partitioned.wbf)
add_test (BUSTED HYPHYMP tests/hbltests/libv3/BUSTED.wbf)
add_test (BUSTED-SRV HYPHYMP tests/hbltests/libv3/BUSTED-SRV.wbf)
add_test (RELAX HYPHYMP tests/hbltests/libv3/RELAX.wbf)
add_test (FUBAR HYPHYMP tests/hbltests/libv3/FUBAR.wbf)
add_test (BGM HYPHYMP tests/hbltests/libv3/BGM.wbf)
add_test (CONTRAST-FEL HYPHYMP tests/hbltests/libv3/CFEL.wbf)
add_test (FADE HYPHYMP tests/hbltests/libv3/FADE.wbf)
add_test (NAME GARD COMMAND HYPHYMP tests/hbltests/libv3/GARD.wbf ${HYPHY_ENV_ARG})
add_test (ABSREL HYPHYMP tests/hbltests/libv3/ABSREL.wbf)