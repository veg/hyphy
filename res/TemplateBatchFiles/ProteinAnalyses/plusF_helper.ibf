/* Array of available empirical models */
plusF_helper.empirical_model_generators = {"LG": "models.protein.LG.ModelDescription",
                                           "WAG": "models.protein.WAG.ModelDescription",
                                           "JTT": "models.protein.JTT.ModelDescription",
                                           "JC": "models.protein.JC.ModelDescription"};

plusF_helper.Rij_options = {"LG":  models.protein.empirical.LG.empirical_R,
                            "WAG": models.protein.empirical.WAG.empirical_R,
                            "JTT": models.protein.empirical.JTT.empirical_R,
                            "JC":  models.protein.empirical.JC.empirical_R};




lfunction plusF_helper.IntermediatePlusF.ModelDescription(type) {
    models.protein.plusF.ModelDescription.model_definition = models.protein.empirical.ModelDescription(type);
    models.protein.plusF.ModelDescription.model_definition ["empirical-rates"] = models.protein.WAG.empirical_Q;
    models.protein.plusF.ModelDescription.model_definition ["frequency-estimator"] = "frequencies.empirical.protein";
    models.protein.plusF.ModelDescription.model_definition ["parameters"] = {"global": {}, "local": {}, "empirical": 19};
    models.protein.plusF.ModelDescription.model_definition ["q_ij"] = "models.protein.WAG._GenerateRate";
    return models.protein.plusF.ModelDescription.model_definition;
}


lfunction plusF_helper.GetFrequenciesHack (data_filter, tree) {

    model_template = "plusF_helper.IntermediatePlusF.ModelDescription";

    components = utility.Array1D(data_filter);
    filters = utility.Map({
        components,
        1
    }["_MATRIX_ELEMENT_ROW_"], "_value_", "''+ '`&nuc_data`_' + _value_");
    for (i = 0; i < components; i += 1) {
        DataSetFilter ^ (filters[i]) = CreateFilter( ^ (data_filter[i]), 1);
    }
    name_space = & user;
    user_model = model.generic.DefineModel(model_template, name_space, {
            "0": "terms.global"
        }, filters, None);
    return user_model["EFV"];
}

// This code is elegant and I will hear nothing to the contrary.
lfunction plusF_helper.BuildCustomNormalizedQ(EFV, rij, alphabet){

    dim  = utility.Array1D (alphabet);

    // Create Q from R, EFV
    Q = {dim,dim};
    rowSums = {dim,1};

    for (i = 0; i < dim; i +=1 ){
        rowSum = 0;
        for ( j = 0; j < dim; j += 1){
            Q[i][j] = rij[i][j] * EFV[j];
            rowSum += rij[i][j] * EFV[j];
        }
        rowSums[i] = -1 * rowSum;
    }

    // Fill in diagonal
    for (i = 0; i < dim; i += 1){
        Q[i][i] = rowSums[i];
    }

    // normalize that mother
    scalar = 0;
    for (i = 0; i < dim; i +=1 ){
        scalar += Q[i][i] * EFV[i];
    }
    scalar = -1*scalar;
    for (i = 0; i < dim; i +=1 ){
        for ( j = 0; j < dim; j += 1){
            Q[i][j] = Q[i][j] / scalar;
        }
    }
    // Now convert it BACK TO hyphy dictionary.
    finalQ  = {};
    for (l1 = 0; l1 < dim - 1; l1 += 1) {
        finalQ[alphabet[l1]] = {};
        for (l2 = l1 + 1; l2 < dim; l2 += 1) {
            (finalQ[alphabet[l1]])[alphabet[l2]] = Q [l1][l2];
        }
    }
    return finalQ;
}