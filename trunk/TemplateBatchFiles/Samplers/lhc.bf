/*---------------------------------------------------------------------------------------------------------------------*/varCount = Abs(COVARIANCE_PARAMETER);usedVars = Rows(COVARIANCE_PARAMETER);inflationFactor = -1;while (inflationFactor <= 0){	fprintf (stdout, "Inflation factor for profile likelihood bounds (>0.0):");	fscanf (stdin,"Number",inflationFactor);}fprintf (stdout, "\nObtaining profile likeihood bounds...\n");svpc = COVARIANCE_PRECISION;COVARIANCE_PRECISION = 0.95;ExecuteCommands ("CovarianceMatrix (covMx, "+LF_NAME+");");profileString = "";profileString * 128;profileString * "Parameter, Lower Bound, MLE, Upper Bound";for (k=0; k<varCount; k=k+1){	profileString * ("\n"+usedVars[k]+","+covMx[k][0]+","+covMx[k][1]+","+covMx[k][2]);}profileString * 0;k = baseResPath+".profile";fprintf (k,CLEAR_FILE,profileString);profileString = 0;COVARIANCE_PRECISION = svpc;stashedValues = {varCount,4};assignmentString = "";assignmentString * 256;variableValues   = {};for (k=0; k<varCount; k=k+1){	aKey 			    = usedVars[k];	ExecuteCommands 	("GetInformation(varRange,"+aKey+");");	stashedValues[k][0] = covMx[k][1];	/* compute the variance of the approximate normal to the left */	leftSTD 		= (covMx[k][1]-covMx[k][0])/1.96 * inflationFactor;	rightSTD		= (covMx[k][2]-covMx[k][1])/1.96 * inflationFactor;	if (leftSTD)	{		SAMPLE_LEFT = Min(1,(covMx[k][1]-varRange[1])/(1.96*leftSTD));		leftSpan	= Min(covMx[k][1]-varRange[1],1.96*leftSTD);	}	else	{		SAMPLE_LEFT = 0;	}	if (rightSTD)	{		SAMPLE_RIGHT = Min(1,(varRange[2]-covMx[k][1])/(1.96*rightSTD));		rightSpan	 = Min(varRange[2]-covMx[k][1],1.96*rightSTD);	}	else	{		SAMPLE_RIGHT = 0;	}	SAMPLE_LEFT  = SAMPLE_N * (SAMPLE_LEFT)/(SAMPLE_LEFT+SAMPLE_RIGHT) $1;	SAMPLE_RIGHT = SAMPLE_N - SAMPLE_LEFT;		/*	fprintf (stdout, aKey, ":", leftSTD, "/", rightSTD, "; ", SAMPLE_LEFT, "-", SAMPLE_RIGHT, "\n",leftSpan,"\n",varRange,"\n");	*/		thisVarValues = {SAMPLE_N,1};		if (SAMPLE_LEFT)	{		weight = 1/SAMPLE_LEFT*(ZCDF (leftSpan/leftSTD)-ZCDF(0));		for (ss = SAMPLE_LEFT-1; ss >= 0; ss = ss - 1)		{			FindRoot(z, ZCDF(x/leftSTD)-ZCDF(thisVarValues[ss+1]/leftSTD)-weight,x,thisVarValues[ss+1],leftSpan);			thisVarValues[ss] = z;		}		for (ss = SAMPLE_LEFT-1; ss >= 0; ss = ss - 1)		{			thisVarValues[ss] = covMx[k][1] - thisVarValues[ss];		}	}		if (SAMPLE_RIGHT)	{		weight = 1/SAMPLE_RIGHT*(ZCDF (rightSpan/rightSTD)-ZCDF(0));		for (ss = SAMPLE_LEFT+1; ss < SAMPLE_N; ss = ss + 1)		{			FindRoot(z, ZCDF(x/rightSTD)-ZCDF(thisVarValues[ss-1]/rightSTD)-weight,x,thisVarValues[ss-1],rightSpan);			thisVarValues[ss] = z;		}		for (ss = SAMPLE_LEFT+1; ss < SAMPLE_N; ss = ss + 1)		{			thisVarValues[ss] = covMx[k][1] + thisVarValues[ss];		}	}		thisVarValues [SAMPLE_LEFT] = covMx[k][1];	stashedValues[k][1] = Max(covMx[k][1]-(covMx[k][1]-covMx[k][0])*inflationFactor,varRange[1]);	stashedValues[k][2] = Min(covMx[k][1]+(covMx[k][2]-covMx[k][1])*inflationFactor,varRange[2]);	stashedValues[k][3] = (stashedValues[k][2]-stashedValues[k][1])/SAMPLE_N;	assignmentString * (aKey+ "=generatedSamples[itCount]["+k+"];\n");	variableValues[k] = thisVarValues;}assignmentString * 0;varCount	= Rows (covMx);generatedSamples = {SAMPLE_N,varCount};indexVector		 = {1,SAMPLE_N}["_MATRIX_ELEMENT_COLUMN_"];fprintf (stdout, "\nDoing Latin hypercube sampling...\n");for (k=0; k<varCount; k=k+1){	permVector = Random (indexVector,0);	lb = stashedValues[k][1];	st = stashedValues[k][3];	for (m = 0; m<SAMPLE_N; m=m+1)	{		generatedSamples[m][k] = (variableValues[k])[permVector[m]];	}}/*fprintf ("/Users/sergei/Desktop/cubedump.bf", CLEAR_FILE, "generatedSamples = ", generatedSamples, ";\nnames = ", usedVars, ";\n", assignmentString, "\n");*/#include "srs.ibf";