/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(COCO_PARSER_H__)
#define COCO_PARSER_H__

#include "wchar.h"
#include "parser2013.h"


#include "Scanner.h"



class Errors {
public:
	int count;			// number of errors detected

	Errors();
	void SynErr(int line, int col, int n);
	void Error(int line, int col, const wchar_t *s);
	void Warning(int line, int col, const wchar_t *s);
	void Warning(const wchar_t *s);
	void Exception(const wchar_t *s);

}; // Errors

class Parser {
private:
	Token *dummyToken;
	int errDist;
	int minErrDist;
	
	_Formula               * f;
	_FormulaParsingContext * fpc;
	_ExecutionList         * hbl_stream;
	

	void SynErr(int n);
	void Get();
	void Expect(int n);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
	bool _parseExpressionsOnly (void) { return hbl_stream == NULL; }

public:
	enum {
		_EOF=0,
		_IDENTIFIER=1,
		_FLOAT=2,
		_SINGLE_QUOTE_STRING=3,
		_DOUBLE_QUOTE_STRING=4,
		_NONE_OBJECT=5,
		_OPEN_PARENTHESIS=6,
		_CLOSE_PARENTHESIS=7,
		_EQUAL=8,
		_ASSIGN=9,
		_ASSIGN_UPPER_BOUND=10,
		_ASSIGN_LOWER_BOUND=11,
		_COMMA=12,
		_CLOSE_BRACE=13,
		_OPEN_BRACE=14,
		_CLOSE_BRACKET=15,
		_OPEN_BRACKET=16,
		_MULTIPLY=17,
		_COLON=18,
		_SEMICOLON=19,
		_PLUS_EQUAL=20,
		_MINUS_EQUAL=21,
		_TIMES_EQUAL=22,
		_DIV_EQUAL=23,
		_GLOBAL_VAR_TOKEN=24,
		_IF_TOKEN=25,
		_ELSE_TOKEN=26,
		_FOR_TOKEN=27,
		_CONTINUE=28,
		_BREAK=29
	};
	int maxT;

	Scanner *scanner;
	Errors  *errors;

	Token *t;			// last recognized token
	Token *la;			// lookahead token
	_List                  loop_contexts;



	Parser(Scanner *scanner, _Formula* = NULL, _FormulaParsingContext* = NULL,
	                         _ExecutionList* = NULL);
	~Parser();
	void SemErr(const wchar_t* msg);

	void ident(_Formula& f, _FormulaParsingContext& fpc, bool global_tag);
	void number(_Formula& f, _FormulaParsingContext& fpc);
	void matrix_row(_SimpleList & matrix_entries, _FormulaParsingContext& fpc, unsigned long& column_count, bool& is_const);
	void expression(_Formula& f, _FormulaParsingContext& fpc);
	void dense_matrix(_Formula& f, _FormulaParsingContext& fpc);
	void matrix_element(_SimpleList & matrix_definition, _FormulaParsingContext& fpc, bool& is_const);
	void sparse_matrix(_Formula& f, _FormulaParsingContext& fpc);
	void function_call(_Formula& f, _FormulaParsingContext& fpc);
	void primitive(_Formula& f, _FormulaParsingContext& fpc);
	void indexing_operation(_Formula& f, _FormulaParsingContext& fpc);
	void reference_like(_Formula& f, _FormulaParsingContext& fpc);
	void power_like(_Formula& f, _FormulaParsingContext& fpc);
	void multiplication_like(_Formula& f, _FormulaParsingContext& fpc);
	void addition_like(_Formula& f, _FormulaParsingContext& fpc);
	void logical_comp(_Formula& f, _FormulaParsingContext& fpc);
	void logical_and(_Formula& f, _FormulaParsingContext& fpc);
	void logical_or(_Formula& f, _FormulaParsingContext& fpc);
	void assignment_op(_Formula& f, _FormulaParsingContext& fpc);
	void statement(_ExecutionList &current_code_stream);
	void block(_ExecutionList &current_code_stream);
	void hyphy_batch_language();

	void Parse();

}; // end Parser



#endif

