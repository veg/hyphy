#define KERNEL_STRING "#define MIN(a,b) ((a)>(b)?(b):(a))\n__kernel void LeafKernel(  __global float* node_cache,\n__global const float* model,\n__global const float* nodRes_cache,\n__global const long* nodFlag_cache,\nlong sites,\nlong characters,\nlong childNodeIndex,\nlong parentNodeIndex,\nlong roundCharacters,\nint intTagState,\nint nodeID,\n__global int* scalings,   \nfloat scalar,\nfloat uFlowThresh\n)\n{\nint gx = get_global_id(0);\nif (gx > characters) return;\nint gy = get_global_id(1);\nif (gy > sites) return;\nlong parentCharacterIndex = parentNodeIndex*sites*roundCharacters + gy*roundCharacters + gx;\nfloat privateParentScratch = 1.0f;\nint scale = 0;\nif (intTagState == 1)\n{\nprivateParentScratch = node_cache[parentCharacterIndex];\nscale = scalings[parentCharacterIndex];\n}\nlong siteState = nodFlag_cache[childNodeIndex*sites + gy];\nprivateParentScratch *= model[nodeID*roundCharacters*roundCharacters + siteState*roundCharacters + gx];\nif (gy < sites && gx < characters)\n{\nnode_cache[parentCharacterIndex] = privateParentScratch;\nscalings[parentCharacterIndex] = scale;\n}\n}\n__kernel void AmbigKernel(     __global float* node_cache,\n__global const float* model,\n__global const float* nodRes_cache,\n__global const long* nodFlag_cache,\nlong sites,\nlong characters,\nlong childNodeIndex,\nlong parentNodeIndex,\nlong roundCharacters,\nint intTagState,\nint nodeID,\n__global int* scalings,              \nfloat scalar,\nfloat uFlowThresh\n)\n{\n\nint tx = get_local_id(0);\nint ty = get_local_id(1);\n\nint gx = get_global_id(0);\nint gy = get_global_id(1);\nlong parentCharacterIndex = parentNodeIndex*sites*roundCharacters + gy*roundCharacters + gx;\nfloat privateParentScratch = 1.0f;\nint scale = 0;\nif (intTagState == 1 && gy < sites && gx < characters)\n{\nprivateParentScratch = node_cache[parentCharacterIndex];\nscale = scalings[parentCharacterIndex];\n}\nfloat sum = 0.f;\nfloat childSum = 0.f;\nint scaleScratch = 0;\n__local float childScratch[BLOCK_SIZE][BLOCK_SIZE];\n__local float modelScratch[BLOCK_SIZE][BLOCK_SIZE];\nint siteState = nodFlag_cache[childNodeIndex*sites + gy];\nint ambig = 0;\nif (siteState < 0)\n{\nambig = 1;\nsiteState = -siteState-1;\n}\nint cChar = 0;\nfor (int charBlock = 0; charBlock < 64/BLOCK_SIZE; charBlock++)\n{\nif (ambig && gy < sites && gx < characters)\nchildScratch[ty][tx] =  nodRes_cache[siteState*characters + (charBlock*BLOCK_SIZE) + tx];\n\n\nelse if (gy < sites && gx < characters)\n{\nif (charBlock*BLOCK_SIZE + tx == siteState)\nchildScratch[ty][tx] = 1;\nelse\nchildScratch[ty][tx] = 0;\n}\nelse\nchildScratch[ty][tx] = 0;\nmodelScratch[ty][tx] = model[nodeID*roundCharacters*roundCharacters + roundCharacters*((charBlock*BLOCK_SIZE)+ty) + gx];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int myChar = 0; myChar < MIN(BLOCK_SIZE, (characters-cChar)); myChar++)\n{\nsum += childScratch[ty][myChar] * modelScratch[myChar][tx];\nchildSum += childScratch[ty][myChar];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\ncChar += BLOCK_SIZE;\n}\nwhile (childSum < 1 && childSum != 0)\n{\nchildSum *= scalar;\nsum *= scalar;\nscaleScratch++;\n}\nscale += scaleScratch;\nprivateParentScratch *= sum;\nif (gy < sites && gx < characters)\n{\nscalings    [parentCharacterIndex]  = scale;\nnode_cache  [parentCharacterIndex]  = privateParentScratch;\n}\n\n\n}\n__kernel void InternalKernel(  __global float* node_cache,\n__global const float* model,\n__global const float* nodRes_cache,\nlong sites,\nlong characters,\nlong childNodeIndex,\nlong parentNodeIndex,\nlong roundCharacters,\nint intTagState,\nint nodeID,\n__global float* root_cache,\n__global int* scalings,\nfloat scalar,\nfloat uFlowThresh,\n__global int* root_scalings\n)\n{\n\nshort tx = get_local_id(0);\nshort ty = get_local_id(1);\n\nshort gx = get_global_id(0);\nint gy = get_global_id(1);\nlong parentCharacterIndex = parentNodeIndex*sites*roundCharacters + gy*roundCharacters + gx;\nfloat privateParentScratch = 1.0f;\nshort scale = 0;\nif (intTagState == 1 && gy < sites && gx < characters)\n{\nprivateParentScratch = node_cache[parentCharacterIndex];\nscale = scalings[parentCharacterIndex];\n}\nfloat sum = 0.f;\nfloat childSum = 0.f;\nint scaleScratch = scalings[childNodeIndex*sites*roundCharacters + gy*roundCharacters + gx];\n__local float  childScratch[BLOCK_SIZE][BLOCK_SIZE];\n__local float  modelScratch[BLOCK_SIZE][BLOCK_SIZE];\nshort cChar = 0;\nfor (int charBlock = 0; charBlock < 64/BLOCK_SIZE; charBlock++)\n{\nchildScratch[ty][tx] =\nnode_cache[childNodeIndex*sites*roundCharacters + roundCharacters*gy + (charBlock*BLOCK_SIZE) + tx];\nmodelScratch[ty][tx] = model[nodeID*roundCharacters*roundCharacters + roundCharacters*((charBlock*BLOCK_SIZE)+ty) + gx];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int myChar = 0; myChar < MIN(BLOCK_SIZE, (characters-cChar)); myChar++)\n{\nsum += childScratch[ty][myChar] * modelScratch[myChar][tx];\nchildSum += childScratch[ty][myChar];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\ncChar += BLOCK_SIZE;\n}\nwhile (childSum < 1 && childSum != 0)\n{\nchildSum *= scalar;\nsum *= scalar;\nscaleScratch++;\n}\nscale += scaleScratch;\nprivateParentScratch *= sum;\nif (gy < sites && gx < characters)\n{\nscalings     [parentCharacterIndex]  = scale;\nroot_scalings[gy*roundCharacters+gx] = scale;\nnode_cache   [parentCharacterIndex]  = privateParentScratch;\nroot_cache   [gy*roundCharacters+gx] = privateParentScratch;\n}\n}\n__kernel void ResultKernel (   __global int* freq_cache,\n__global float* prob_cache,\n__global fpoint* result_cache,\n__global float* root_cache,\n__global int* root_scalings,\nlong sites,\nlong roundCharacters,\nfloat scalar,\nlong characters\n)\n{\n\n#ifdef __GPUResults__\nint site = get_global_id(0);\nint localSite = get_local_id(0);\n__local fpoint resultScratch[BLOCK_SIZE*BLOCK_SIZE];\nresultScratch[localSite] = 0.0;\nwhile (site < sites)\n{\nresult_cache[site] = 0.0;\nfpoint acc = 0.0;\nint scale = root_scalings[site*roundCharacters];\nfor (int rChar = 0; rChar < characters; rChar++)\n{\nacc += root_cache[site*roundCharacters + rChar] * prob_cache[rChar];\n}\n\nresultScratch[localSite] += (log(acc)-scale*log(scalar)) * freq_cache[site];\n\nsite += get_global_size(0);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int offset = get_local_size(0)/2; offset > 0; offset >>= 1)\n{\nif (localSite < offset)\n{\nfpoint other = resultScratch[localSite + offset];\nfpoint mine  = resultScratch[localSite];\nresultScratch[localSite] = mine+other;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n\nif (localSite == 0) result_cache[get_group_id(0)] = resultScratch[0];\n#else\nif (get_global_id(0) != 0) return;\nint site = get_global_id(1);\nresult_cache[site] = 0.0;\nif (get_group_id(1) >= get_local_size(0)*get_local_size(1)) return;\nwhile (site < sites)\n{\nfloat acc = 0.0;\nint scale = root_scalings[site*roundCharacters];\nfor (int rChar = 0; rChar < characters; rChar++)\n{\nacc += root_cache[site*roundCharacters + rChar] * prob_cache[rChar];\n}\nresult_cache[site] += (native_log(acc)-scale*native_log(scalar)) * freq_cache[site];\nsite += get_local_size(0)*get_local_size(1);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n#endif\n\n\n}\n__kernel void ReductionKernel ( __global double* result_cache\n)\n{\nint groupNum = get_local_id(0);\n__local double resultScratch[BLOCK_SIZE*BLOCK_SIZE];\nresultScratch[groupNum] = result_cache[groupNum];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int offset = get_local_size(0)/2; offset > 0; offset >>= 1)\n{\nif (groupNum < offset)\n{\ndouble other = resultScratch[groupNum + offset];\ndouble mine  = resultScratch[groupNum];\ndouble sum  = mine + other;\n\nresultScratch[groupNum]  = sum;\n\n\n\n\n\n\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nresult_cache[groupNum] = resultScratch[groupNum];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n"

